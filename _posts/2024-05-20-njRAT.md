---
title: njRAT Malware Analysis
date: 2024-05-20 12:00:00
categories: [Malware Analysis]
tags: [njrat,malware analysis]
comments: false
---

## Introduction

[njRAT](https://en.wikipedia.org/wiki/NjRAT), also known as Bladabindi, is a remote access tool (RAT) with user interface or trojan which allows the holder of the program to control the end-user's computer. It was first found in June 2013 with some variants traced to November 2012. It was made by a hacking organization from different countries called M38dHhM and was often used against targets in the Middle East. It can be spread through phishing and infected drives.

## njRAT Creator

The njRAT creator comes with quite a bit of files including a folder named "Plugin" which contains 6 dll files.
![Desktop View](/assets/images/FileStructure.png){: width="972" height="589"}
![Desktop View](/assets/images/FileStructure_1.png){: width="972" height="589"}

Upon executing the RAT creator it asks for a "Port" value which is the port the njRAT server should listen on.
![Desktop View](/assets/images/RAT_Creator.png){: width="972" height="589"}

At the bottom of the window we see an option called "Builder" which upon clicking opens a "Builder" window which is where we can select options and build our malware.

I build the malware with a few options selected as can be seen below
![Desktop View](/assets/images/RAT_Creator_Build.png){: width="972" height="589"}

## Static Analysis

I started by taking a quick look at the created executable file properties but I did not find anything interesting.

Upon checking the PE file header I did not find anything unusual but I did find the presence of a .NET header indicating this is a .NET executable.

Checking the strings on file we get some interesting strings as listed below:
*tobeadded*

### DnSpy

Since this is an .NET executable I decided to open the executable using DnSpy.

Starting with the main function. The main function calls another function "ko" in "OK"
![Desktop View](/assets/images/OK.ko.png){: width="972" height="589"}

In function "ko", it starts by checking if the malware was executed with any commandline arguments. If it was executed with commandline arguments then in registry under CurrentUser it sets the value of string “di” to “!” and then it puts the malware to sleep for 5000 seconds.
![Desktop View](/assets/images/command_line_argument.png){: width="972" height="589"}

Then it creates a Mutex named "c4c160b1fc78444b2eebcebdee0dcb39". If the Mutex already exist then it terminates the executable.
![Desktop View](/assets/images/Mutex.png){: width="972" height="589"}

Then we see a call to function “INS” in “OK”.
In the "INS" function, the initial action involves pausing the thread for 1000 seconds. Following this, while building the malware we had an option to "Copy" the malware if that option was selected then it checks if a file already exist at the choosen location with the choosen name if it does then it deletes that file and then copies the malware to the choosen location with the choosen name. After this it starts the malawre process from there and terminates the current process.
![Desktop View](/assets/images/Copy.png){: width="972" height="589"}

After this the malware adds itself itself to permitted programs in firewall settings and enables it using the command "netsh firewall add allowedprogram \”*executable path*\*executable name*\ ENABLE"
![Desktop View](/assets/images/Firewall.png){: width="972" height="589"}

Following this if we had selected "Registry StarUP" option when building the malware then in registry under CurrentUser it creates an entry at location "Software\Microsoft\Windows\CurrentVersion\Run" with value “*/path/and/name/of/executable*”.
![Desktop View](/assets/images/Registry.png){: width="972" height="589"}

If we had selected “copy to StartUP” option when building the malware it sets the malware file attribute to hidden and copies it to windows startup folder.
![Desktop View](/assets/images/Startup.png){: width="972" height="589"}

If the "Kill process" option is selected then it terminates the process specified using the command "taskkill /F /IM *process name*".
![Desktop View](/assets/images/Taskkill.png){: width="972" height="589"}

If the option "Hidden" is selected then it sets the file attribute of the malware to hidden.
![Desktop View](/assets/images/Hidden.png){: width="972" height="589"}

If the option "USB spread" was selected then for all logical drives with Program Files folder it copies the malware to the Program Files folder and names it the name chosen when building the malware then it sets the file property of the malware at that location to hidden. Additionally, it creates a file named "autorun.inf" in the same folder and writes the following thing in that file:
[autorun]
open=Program_files_location\name_of_malware_file
shellexecute = Program_files_location
![Desktop View](/assets/images/USBSpread.png){: width="972" height="589"}

After this we exit the "INS" function and go back to the "ko" function.

It then creates a new thread using the function RC. RC function at first glance seems to handle the network connection aspect of the malware. Upon connecting to the C&C server it sends basic information about the computer to the server such as machine name, username, OS info etc separated by "&#124;&#39;&#124;&#39;" as shown below:
![Desktop View](/assets/images/network_start.png){: width="972" height="589"}
![Desktop View](/assets/images/network_start_variable.png){: width="972" height="589"}

It also sends the functionality available on the malware i.e. the options we chose when building the malware. Furthermore, it goes into an infinite loop and waits for server to send a message and depend-ing on the message received it carries out the required activity for example if the server sends “kl” then the malware sends back keylogs. So in a sense they have created shotform of the commands and use that to communicate with the malware.
![Desktop View](/assets/images/Command.png){: width="972" height="589"}

Then it create another thread using the WRK function. This particular function serves the purpose of capturing keyboard inputs and it saves the logged keystrokes within the registry at location:
CurrentUser/Software/*malware_name*
![Desktop View](/assets/images/WRK.png){: width="972" height="589"}

Then if “Protect process” option was selected it creates another thread using the function protect. This function continously checks if process "taskmanager", "processviewer" or "processhacker" are in foreground or if a process with window title "process explorer" is running. If any of these processes are detected, it proceeds to disable keyboard or mouse input to it and sends an End Process message to terminate the process. At the beginning of each iteration of the loop, it pauses the thread for 200 seconds.
![Desktop View](/assets/images/Protect.jpeg){: width="972" height="589"}

Then if "Anti Kill" option was selected it sets ProcessInformationClass of the process to a value of 29 which corresponds to "ProcessBreakOnTermination". Essentially if the process is terminated then it will result in BSOD(Blue Screen of Death).
![Desktop View](/assets/images/BSOD.png){: width="972" height="589"}
![Desktop View](/assets/images/BSOD2.png){: width="972" height="589"}

## Dynamic Analysis

In order to better analyse the malware during dynamic analysis I rebuild the malware using all options selected except the "Icon" option as seen below:
![Desktop View](/assets/images/Rebuild.png){: width="972" height="589"}
I then started listening for connection on one VM while executing the malware on another one.
Upon execution as we had selected the "Hidden" option the malware sets its file attribute to Hidden.
![Desktop View](/assets/images/Hidden.png){: width="972" height="589"}

Similarly, as we had chosen Copy option with ExeName as "server.exe" and directory "%TEMP%", it copied the file to temp directory with name server.exe. It also set the file attribute of this file to hidden.
![Desktop View](/assets/images/Copy_Temp.png){: width="972" height="589"}
![Desktop View](/assets/images/Copy_Hidden.png){: width="972" height="589"}

Similarly, since we had copy to registry option selected. It added an entry in autorun for the malware. One thing to note here is that the name of registry key is different from the one we saw during static analysis that is likely because the malware generate random 32 character length name everytime the malware is built. Also it was not able to add entry to LocalMachine because the malware was executed with user permission and not administrative permission. 
![Desktop View](/assets/images/Autorun.png){: width="972" height="589"}

At the start of malware execution it adds a key named "di" to CurrentUser which can be seen below:
![Desktop View](/assets/images/di.png){: width="972" height="589"}

In our static analysis, we discovered that the malware stores keylogs in the registry path "CurrentUser\Software*malware name*". This can be seen below:
![Desktop View](/assets/images/keylog.png){: width="972" height="589"}

Similarly, sinc we had copy to startUP option selected. It copied the file to startup folder and set its file attribute to hidden.
![Desktop View](/assets/images/Startup.png){: width="972" height="589"}
![Desktop View](/assets/images/Startup_Hidden.png){: width="972" height="589"}

Taking a look at network traffic between the server and the malware. It seems they are communicating with each other using TCP protocol with no encryption. After the typical handshake the first packet the malware sends to server is the information about the computer as can be seen below:
![Desktop View](/assets/images/Network_Basic.png){: width="972" height="589"}
![Desktop View](/assets/images/Network_Basic_Better_View.png){: width="972" height="589"}

The second value that it is sending which is “SGFjS2VkX0MzOEQ0MDE=” it base64 encoded string that translates to “HacKed_C38D401”. HacKed was the victim name we set when we were creating the malware.

Then it sends the information about the functionality available on the malware which includes the name of the victim, ip address and port, location the file is executing from, file name and then it an-swers ‘True’ or ‘False’ depending on whether the malware has the functionality or not all of this information is base64 encoded as can be seen below:
![Desktop View](/assets/images/Network_Functionality.png){: width="972" height="589"}
![Desktop View](/assets/images/Network_Functionality_Better_View.png){: width="972" height="589"}

It also sends the name of the window that is in the foreground this information is also base64 encoded as can be seen below:
![Desktop View](/assets/images/Network_Foreground.png){: width="972" height="589"}
![Desktop View](/assets/images/Network_Foreground_Better_View.png){: width="972" height="589"}

Upon clicking Keylogger option on our server it sends "kl" command to the malware using a network packet and the malware replies back with the keylogs as can be seen below:
![Desktop View](/assets/images/Network_Keylog.png){: width="972" height="589"}
![Desktop View](/assets/images/Network_Keylog_kl_answer.png){: width="972" height="589"}
![Desktop View](/assets/images/Network_Keylog_kl_answer_decode.png){: width="972" height="589"}
![Desktop View](/assets/images/Network_Keylog_kl_UI.png){: width="972" height="589"}




 









